// Copyright (c) Gabriel de Quadros Ligneul
// SPDX-License-Identifier: MIT (see LICENSE)

package codegen

type tmplData struct {
	Package string
	JsonAbi string
	Structs map[string]tmplStruct
	Schemas []tmplSchema
}

type tmplStruct struct {
	ID     string
	Kind   string
	GoName string
	Fields []tmplField
}

type tmplSchema struct {
	ID     []byte
	Kind   string
	GoName string
	Fields []tmplField
}

type tmplField struct {
	Kind   string
	GoName string
	Type   string
}

const tmplSource = `// Code generated by EggRoll - DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/gligneul/eggroll/pkg/eggtypes"
)

var (
	_ = big.NewInt
	_ = common.Big1
	_ = eggtypes.MustAddSchema
)

//
// Types
//

{{range $struct := .Structs}}
	type {{$struct.GoName}} struct {
	{{range $field := .Fields}}
		{{$field.GoName}} {{$field.Type}}{{end}}
	}
{{end}}

{{range $schema := .Schemas}}
	// Schema with selector {{printf "%x" $schema.ID}}
	type {{$schema.GoName}} struct {
	{{range $field := .Fields}}
		{{$field.GoName}} {{$field.Type}}
	{{end}}
	}
{{end}}

//
// IDs
//

{{range $schema := .Schemas}}
	// {{$schema.Kind}} ID
	var {{$schema.GoName}}ID = [4]byte{ {{range $i := $schema.ID}}{{printf "0x%x" $i}}, {{end}} }
{{end}}

//
// Encode
//

{{range $schema := .Schemas}}
	// Encode {{$schema.Kind}} into binary data.
	func Encode{{$schema.GoName}}(
		{{- range $field := .Fields}}
			{{$field.GoName}} {{$field.Type}},
		{{- end}}
	) []byte {
		values := make([]any, {{- len $schema.Fields}})
		{{- range $i, $field := .Fields}}
			values[{{$i}}] = {{$field.GoName}}
		{{- end}}
		data, err := _abi.Methods["{{$schema.Kind}}"].Inputs.PackValues(values)
		if err != nil {
			panic(fmt.Sprintf("failed to encode {{$schema.Kind}}: %v", err))
		}
		return append({{$schema.GoName}}ID[:], data...)
	}

	// Encode {{$schema.Kind}} into binary data.
	func (v {{$schema.GoName}}) Encode() []byte {
		return Encode{{$schema.GoName}}(
		{{- range $field := .Fields}}
			v.{{$field.GoName}},
		{{- end}}
		)
	}
{{end}}

//
// Decode
//

{{range $schema := .Schemas}}
	func _decode_{{$schema.GoName}}(values []any) (any, error) {
		if len(values) != {{len $schema.Fields}} {
			return nil, fmt.Errorf("wrong number of values")
		}
		{{- if $schema.Fields}}
			var ok bool
		{{- end}}
		var v {{$schema.GoName}}
		{{- range $i, $field := .Fields}}
			v.{{$field.GoName}}, ok = values[{{$i}}].({{$field.Type}})
			if !ok {
				return nil, fmt.Errorf("failed to decode {{$schema.Kind}}.{{$field.Kind}}")
			}
		{{- end}}
		return v, nil
	}
{{end}}

//
// Init
//

{{/* This might be unsafe but it is easier to debug.
       An alternative is to use 'printf "%q" .JsonAbi'. */}}
const _JSON_ABI = ` + "`" + `{{.JsonAbi}}
` + "`" + `

var _abi abi.ABI

func init() {
	var err error
	_abi, err = abi.JSON(strings.NewReader(_JSON_ABI))
	if err != nil {
		// This should not happen
		panic(fmt.Sprintf("failed to decode ABI: %v", err))
	}
	{{- range $schema := .Schemas}}
		eggtypes.MustAddSchema(eggtypes.MessageSchema{
			ID:        {{$schema.GoName}}ID,
			Kind:      "{{$schema.Kind}}",
			Arguments: _abi.Methods["{{$schema.Kind}}"].Inputs,
			Decoder:   _decode_{{$schema.GoName}},
		})
	{{- end}}
}
`
