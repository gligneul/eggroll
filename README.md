# EggRoll üê£üõº

![build](https://github.com/gligneul/eggroll/actions/workflows/go.yml/badge.svg)

A high-level, opinionated, lambda-based framework for Cartesi Rollups in Go.

EggRoll divides a Cartesi DApp into two parts: contract and client.
The contract runs in the blockchain inside a Cartesi VM and relies on the Cartesi Rollups API.
The client runs off-chain and communicates with the contract using the Cartesi Reader Node APIs and the Ethereum API.
EggRoll provides abstractions for both sides of the DApp.

## Requirements

EggRoll is built on top of the [Cartesi Rollups](https://docs.cartesi.io/cartesi-rollups/) infrastructure version 1.0.
To use EggRoll, you also need [sunodo](https://github.com/sunodo/sunodo/) version 0.9.

## Quick Look

Let's look at a simple example: a DApp that keeps a text box in the blockchain.
In EggRoll, you should first define the package shared between the DApp contract and the client.
Below, the structs `Append` and `Clear` are types sent from the client to the contract.
Then, you should define the `Contract` struct that will advance the rollups state.
This struct should implement two methods, `Decoders` and `Advance`.
The `Decoders` method returns the decoders that automatically convert the binary input data to Go types.
The `Advance` method receives an input and advances the contract to the next state.

<!---
sed -e '0,/@cut/d' ./examples/textbox/textbox.go
-->
```go
type (
	Append struct {
		Value string
	}
	Clear struct{}
)

type Contract struct {
	TextBox string
}

func (c *Contract) Decoders() []eggroll.Decoder {
	return []eggroll.Decoder{
		eggroll.NewGenericDecoder[Clear](),
		eggroll.NewGenericDecoder[Append](),
	}
}

func (c *Contract) Advance(env *eggroll.Env, input any) error {
	switch input := input.(type) {
	case *Clear:
		env.Logln("received input clear")
		c.TextBox = ""
	case *Append:
		env.Logf("received input append with '%v'\n", input.Value)
		c.TextBox += input.Value
	default:
		return fmt.Errorf("invalid input")
	}
	return nil
}
```

To run the contract, you should create a separate main package that imports the contract and call the `eggroll.Roll` function.

<!---
sed -e '0,/@cut/d' ./examples/textbox/contract/main.go
-->
```go
func main() {
	eggroll.Roll(&textbox.Contract{})
}
```

Finally, you can interact with the DApp contract from the client using the `eggroll.Client` struct.
In the example below, `SendGeneric` sends inputs to the contract through the Ethereum API;
`WaitFor` waits for the given input to be processed by the contract;
`Sync` synchronizes the DApp state from the contract to the client;
`ReadState` reads the contract state from the Cartesi reader node;
and `Logs` reads the logs generated by the contract with the `env.Log` functions.

<!---
sed -e '0,/@cut/d' ./examples/textbox/client/main.go
-->
```go
func main() {
	ctx := context.Background()
	client := eggroll.NewClient()

	inputs := []any{
		textbox.Clear{},
		textbox.Append{Value: "egg"},
		textbox.Append{Value: "roll"},
	}
	for _, input := range inputs {
		log.Printf("Sending input %#v\n", input)
		Check(client.SendGeneric(ctx, input))
	}

	log.Println("Waiting for inputs to be processed")
	Check(client.WaitFor(ctx, 2))

	Check(client.Sync(ctx))
	var contract textbox.Contract
	Check(client.ReadState(&contract))
	log.Printf("Text box: '%v'\n", contract.TextBox)

	logs := Must(client.Logs(ctx))
	log.Println("Logs:")
	for _, msg := range logs {
		log.Print(">", msg)
	}
}
```

To run this example, check the README in `./examples/textbox`.
