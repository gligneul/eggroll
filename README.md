# EggRoll üê£üõº

A high-level, opinionated, lambda-based framework for Cartesi Rollups in Go.

![build](https://github.com/gligneul/eggroll/actions/workflows/go.yml/badge.svg)

## Requirements

EggRoll is built on top of the [Cartesi Rollups](https://docs.cartesi.io/cartesi-rollups/) infrastructure version 1.0.
To use EggRoll, you also need [sunodo](https://github.com/sunodo/sunodo/) version 0.8.

## Quick Look

EggRoll divides the DApp into two parts: contract and client.
The contract runs in the blockchain inside a Cartesi VM and relies on the Cartesi Rollups API.
The client runs off-chain and communicates with the contract using the Cartesi Reader Node APIs and the Ethereum API.
EggRoll provides abstractions for both sides of the DApp.

Let's look at a simple example: a DApp that keeps a text box in the blockchain.
In EggRoll, you should first define the types shared between the DApp contract and the client.
The structs `InputAppend` and `InputClear` are types sent from the client to the contract.
The struct `State` is the contract's internal state that will also be available to the client for reading.

<!---
sed -e '0,/@cut/d' ./examples/textbox/textbox.go
-->
```go
type InputAppend struct {
	Value string
}

type InputClear struct {
}

type State struct {
	TextBox string
}
```

Then, you should implement the `Advance` method for the DApp state.
This method receives the new input that advances the rollups.
You should also register the decoders of each input type the contract receives.
The `eggroll.NewGenericDecoder` provides a generic implementation for decoding inputs.
After registering all decoders, call `Roll` to run the contract.

<!---
sed -e '0,/@cut/d' ./examples/textbox/contract/main.go
-->
```go
func (s *State) Advance(env *eggroll.Env, input any) error {
	switch input := input.(type) {
	case *InputClear:
		env.Logln("received input clear")
		s.TextBox = ""
	case *InputAppend:
		env.Logf("received input append with '%v'\n", input.Value)
		s.TextBox += input.Value
	default:
		return fmt.Errorf("invalid input")
	}
	return nil
}

func main() {
	contract := eggroll.NewContract(&State{})
	contract.AddDecoder(eggroll.NewGenericDecoder[InputClear]())
	contract.AddDecoder(eggroll.NewGenericDecoder[InputAppend]())
	contract.Roll()
}
```

Finally, you can interact with the DApp contract from the client using the `eggroll.Client` struct.
`SendGeneric` sends inputs to the contract through the Ethereum API.
`WaitFor` waits for the given number of inputs to be processed by the contract.
`Sync` synchronizes the DApp state from the contract to the client.
`ReadState` reads the contract state from the Cartesi reader node.
`Logs` reads the logs generated by the contract with the `env.Log` functions.

<!---
sed -e '0,/@cut/d' ./examples/textbox/client/main.go
-->
```go
func main() {
	ctx := context.Background()
	client := eggroll.NewClient()

	inputs := []any{
		InputClear{},
		InputAppend{Value: "egg"},
		InputAppend{Value: "roll"},
	}
	for _, input := range inputs {
		log.Printf("Sending input %#v\n", input)
		Check(client.SendGeneric(ctx, input))
	}

	log.Println("Waiting for inputs to be processed")
	Check(client.WaitFor(ctx, 2))

	Check(client.Sync(ctx))
	var state State
	Check(client.ReadState(&state))
	log.Printf("Text box: '%v'\n", state.TextBox)

	logs := Must(client.Logs(ctx))
	log.Println("Logs:")
	for _, msg := range logs {
		log.Print(">", msg)
	}
}
```

To run this example, check the README in `./examples/textbox`.
