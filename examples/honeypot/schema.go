// Code generated by EggRoll - DO NOT EDIT.

package main

import (
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/gligneul/eggroll/pkg/eggroll"
	"github.com/gligneul/eggroll/pkg/eggtypes"
)

var (
	_ = big.NewInt
	_ = common.Big1
	_ = eggtypes.MustAddSchema
)

// Messages encoded as JSON ABI.
const _JSON_ABI = `[
  {
    "name": "currentBalance",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256",
        "components": null
      }
    ],
    "outputs": null
  },
  {
    "name": "deposit",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": null,
    "outputs": null
  },
  {
    "name": "withdraw",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256",
        "components": null
      }
    ],
    "outputs": null
  }
]
`

// Solidity ABI.
var _abi abi.ABI

//
// Struct Types
//

// Return the current balance of the honeypot.
type CurrentBalance struct {
	Balance *big.Int
}

// Deposit Ether to the honeypot.
// This input should be sent through the Ether portal.
type Deposit struct {
}

// Withdraw the given value from honeypot.
// The contract only process this input if it come from the owner.
type Withdraw struct {
	Value *big.Int
}

//
// ID for each schema
//

// 4-byte function selector of currentBalance
var CurrentBalanceID eggtypes.ID

// 4-byte function selector of deposit
var DepositID eggtypes.ID

// 4-byte function selector of withdraw
var WithdrawID eggtypes.ID

//
// Encode functions for each message schema
//

// Encode currentBalance into binary data.
func EncodeCurrentBalance(
	Balance *big.Int,
) []byte {
	values := make([]any, 1)
	values[0] = Balance
	data, err := _abi.Methods["currentBalance"].Inputs.PackValues(values)
	if err != nil {
		panic(fmt.Sprintf("failed to encode currentBalance: %v", err))
	}
	return append(CurrentBalanceID[:], data...)
}

// Encode currentBalance into binary data.
func (v CurrentBalance) Encode() []byte {
	return EncodeCurrentBalance(
		v.Balance,
	)
}

// Encode deposit into binary data.
func EncodeDeposit() []byte {
	values := make([]any, 0)
	data, err := _abi.Methods["deposit"].Inputs.PackValues(values)
	if err != nil {
		panic(fmt.Sprintf("failed to encode deposit: %v", err))
	}
	return append(DepositID[:], data...)
}

// Encode deposit into binary data.
func (v Deposit) Encode() []byte {
	return EncodeDeposit()
}

// Encode withdraw into binary data.
func EncodeWithdraw(
	Value *big.Int,
) []byte {
	values := make([]any, 1)
	values[0] = Value
	data, err := _abi.Methods["withdraw"].Inputs.PackValues(values)
	if err != nil {
		panic(fmt.Sprintf("failed to encode withdraw: %v", err))
	}
	return append(WithdrawID[:], data...)
}

// Encode withdraw into binary data.
func (v Withdraw) Encode() []byte {
	return EncodeWithdraw(
		v.Value,
	)
}

//
// Decode functions for each message schema
//

func _decode_CurrentBalance(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v CurrentBalance
	v.Balance, ok = values[0].(*big.Int)
	if !ok {
		return nil, fmt.Errorf("failed to decode currentBalance.balance")
	}
	return v, nil
}

func _decode_Deposit(values []any) (any, error) {
	if len(values) != 0 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var v Deposit
	return v, nil
}

func _decode_Withdraw(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v Withdraw
	v.Value, ok = values[0].(*big.Int)
	if !ok {
		return nil, fmt.Errorf("failed to decode withdraw.value")
	}
	return v, nil
}

//
// Init function
//

func init() {
	var err error
	_abi, err = abi.JSON(strings.NewReader(_JSON_ABI))
	if err != nil {
		// This should not happen
		panic(fmt.Sprintf("failed to decode ABI: %v", err))
	}
	CurrentBalanceID = eggtypes.ID(_abi.Methods["currentBalance"].ID)
	eggtypes.MustAddSchema(eggtypes.MessageSchema{
		ID:        CurrentBalanceID,
		Kind:      "currentBalance",
		Arguments: _abi.Methods["currentBalance"].Inputs,
		Decoder:   _decode_CurrentBalance,
	})
	DepositID = eggtypes.ID(_abi.Methods["deposit"].ID)
	eggtypes.MustAddSchema(eggtypes.MessageSchema{
		ID:        DepositID,
		Kind:      "deposit",
		Arguments: _abi.Methods["deposit"].Inputs,
		Decoder:   _decode_Deposit,
	})
	WithdrawID = eggtypes.ID(_abi.Methods["withdraw"].ID)
	eggtypes.MustAddSchema(eggtypes.MessageSchema{
		ID:        WithdrawID,
		Kind:      "withdraw",
		Arguments: _abi.Methods["withdraw"].Inputs,
		Decoder:   _decode_Withdraw,
	})
}

//
// Middleware
//

// High-level contract
type iContract interface {

	// Deposit Ether to the honeypot.
	// This input should be sent through the Ether portal.
	Deposit(
		eggroll.Env,
	) error

	// Withdraw the given value from honeypot.
	// The contract only process this input if it come from the owner.
	Withdraw(
		eggroll.Env,
		*big.Int,
	) error
}

// Middleware that implements the EggRoll Middleware interface.
// The middleware requires a high-level contract to work.
type Middleware struct {
	contract iContract
}

func (m Middleware) Advance(env eggroll.Env, input []byte) error {
	unpacked, err := eggtypes.Decode(input)
	if err != nil {
		return err
	}
	env.Logf("middleware: received %#v", unpacked)
	switch input := unpacked.(type) {
	case Deposit:
		return m.contract.Deposit(
			env,
		)
	case Withdraw:
		return m.contract.Withdraw(
			env,
			input.Value,
		)
	default:
		return fmt.Errorf("middleware: input isn't an advance")
	}
}

func (m Middleware) Inspect(env eggroll.EnvReader, input []byte) error {
	return fmt.Errorf("inspect not supported")
}

// Call eggroll.Roll for the contract using the middleware wrapper.
func Roll(contract iContract) {
	eggroll.Roll(Middleware{contract})
}
