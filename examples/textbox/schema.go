// Code generated by EggRoll - DO NOT EDIT.

package main

import (
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/gligneul/eggroll/pkg/eggroll"
	"github.com/gligneul/eggroll/pkg/eggtypes"
)

var (
	_ = big.NewInt
	_ = common.Big1
	_ = eggtypes.MustAddSchema
)

// Messages encoded as JSON ABI.
const _JSON_ABI = `[
  {
    "name": "currentState",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "value",
        "type": "string",
        "internalType": "string",
        "components": null
      }
    ],
    "outputs": null
  },
  {
    "name": "append",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "value",
        "type": "string",
        "internalType": "string",
        "components": null
      }
    ],
    "outputs": null
  },
  {
    "name": "clear",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": null,
    "outputs": null
  }
]
`

// Solidity ABI.
var _abi abi.ABI

//
// Struct Types
//

type CurrentState struct {
	Value string
}

type Append struct {
	Value string
}

type Clear struct {
}

//
// ID for each schema
//

// 4-byte function selector of currentState
var CurrentStateID eggtypes.ID

// 4-byte function selector of append
var AppendID eggtypes.ID

// 4-byte function selector of clear
var ClearID eggtypes.ID

//
// Encode functions for each message schema
//

// Encode currentState into binary data.
func EncodeCurrentState(
	Value string,
) []byte {
	values := make([]any, 1)
	values[0] = Value
	data, err := _abi.Methods["currentState"].Inputs.PackValues(values)
	if err != nil {
		panic(fmt.Sprintf("failed to encode currentState: %v", err))
	}
	return append(CurrentStateID[:], data...)
}

// Encode currentState into binary data.
func (v CurrentState) Encode() []byte {
	return EncodeCurrentState(
		v.Value,
	)
}

// Encode append into binary data.
func EncodeAppend(
	Value string,
) []byte {
	values := make([]any, 1)
	values[0] = Value
	data, err := _abi.Methods["append"].Inputs.PackValues(values)
	if err != nil {
		panic(fmt.Sprintf("failed to encode append: %v", err))
	}
	return append(AppendID[:], data...)
}

// Encode append into binary data.
func (v Append) Encode() []byte {
	return EncodeAppend(
		v.Value,
	)
}

// Encode clear into binary data.
func EncodeClear() []byte {
	values := make([]any, 0)
	data, err := _abi.Methods["clear"].Inputs.PackValues(values)
	if err != nil {
		panic(fmt.Sprintf("failed to encode clear: %v", err))
	}
	return append(ClearID[:], data...)
}

// Encode clear into binary data.
func (v Clear) Encode() []byte {
	return EncodeClear()
}

//
// Decode functions for each message schema
//

func _decode_CurrentState(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v CurrentState
	v.Value, ok = values[0].(string)
	if !ok {
		return nil, fmt.Errorf("failed to decode currentState.value")
	}
	return v, nil
}

func _decode_Append(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v Append
	v.Value, ok = values[0].(string)
	if !ok {
		return nil, fmt.Errorf("failed to decode append.value")
	}
	return v, nil
}

func _decode_Clear(values []any) (any, error) {
	if len(values) != 0 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var v Clear
	return v, nil
}

//
// Init function
//

func init() {
	var err error
	_abi, err = abi.JSON(strings.NewReader(_JSON_ABI))
	if err != nil {
		// This should not happen
		panic(fmt.Sprintf("failed to decode ABI: %v", err))
	}
	CurrentStateID = eggtypes.ID(_abi.Methods["currentState"].ID)
	eggtypes.MustAddSchema(eggtypes.MessageSchema{
		ID:        CurrentStateID,
		Kind:      "currentState",
		Arguments: _abi.Methods["currentState"].Inputs,
		Decoder:   _decode_CurrentState,
	})
	AppendID = eggtypes.ID(_abi.Methods["append"].ID)
	eggtypes.MustAddSchema(eggtypes.MessageSchema{
		ID:        AppendID,
		Kind:      "append",
		Arguments: _abi.Methods["append"].Inputs,
		Decoder:   _decode_Append,
	})
	ClearID = eggtypes.ID(_abi.Methods["clear"].ID)
	eggtypes.MustAddSchema(eggtypes.MessageSchema{
		ID:        ClearID,
		Kind:      "clear",
		Arguments: _abi.Methods["clear"].Inputs,
		Decoder:   _decode_Clear,
	})
}

//
// Middleware
//

// High-level contract
type iContract interface {
	Append(
		eggroll.Env,
		string,
	) error

	Clear(
		eggroll.Env,
	) error
}

// Middleware that implements the EggRoll Middleware interface.
// The middleware requires a high-level contract to work.
type Middleware struct {
	contract iContract
}

func (m Middleware) Advance(env eggroll.Env, input []byte) error {
	unpacked, err := eggtypes.Decode(input)
	if err != nil {
		return err
	}
	env.Logf("middleware: received %#v", unpacked)
	switch input := unpacked.(type) {
	case Append:
		return m.contract.Append(
			env,
			input.Value,
		)
	case Clear:
		return m.contract.Clear(
			env,
		)
	default:
		return fmt.Errorf("middleware: input isn't an advance")
	}
}

func (m Middleware) Inspect(env eggroll.EnvReader, input []byte) error {
	return fmt.Errorf("inspect not supported")
}

// Call eggroll.Roll for the contract using the middleware wrapper.
func Roll(contract iContract) {
	eggroll.Roll(Middleware{contract})
}
