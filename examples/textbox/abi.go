// Code generated by EggRoll - DO NOT EDIT.

package main

import (
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/gligneul/eggroll/pkg/eggtypes"
)

var (
	_ = big.NewInt
	_ = common.Big1
	_ = eggtypes.Pack
)

//
// Types
//

// Message with selector 86cdbae9
type Append struct {
	Value string
}

// Message with selector 52efea6e
type Clear struct {
}

// Message with selector 09df59d0
type TextBox struct {
	Value string
}

//
// IDs
//

// Append ID (86cdbae9)
var AppendID = [4]byte{134, 205, 186, 233}

// Clear ID (52efea6e)
var ClearID = [4]byte{82, 239, 234, 110}

// TextBox ID (09df59d0)
var TextBoxID = [4]byte{9, 223, 89, 208}

//
// JSON ABI
//

const _JSON_ABI = "[\n  {\n    \"name\": \"append\",\n    \"type\": \"function\",\n    \"stateMutability\": \"nonpayable\",\n    \"inputs\": [\n      {\n        \"name\": \"value\",\n        \"type\": \"string\",\n        \"internalType\": \"string\",\n        \"components\": null\n      }\n    ],\n    \"outputs\": null\n  },\n  {\n    \"name\": \"clear\",\n    \"type\": \"function\",\n    \"stateMutability\": \"nonpayable\",\n    \"inputs\": null,\n    \"outputs\": null\n  },\n  {\n    \"name\": \"textBox\",\n    \"type\": \"function\",\n    \"stateMutability\": \"nonpayable\",\n    \"inputs\": [\n      {\n        \"name\": \"value\",\n        \"type\": \"string\",\n        \"internalType\": \"string\",\n        \"components\": null\n      }\n    ],\n    \"outputs\": null\n  }\n]"

//
// Pack
//

// Pack message Append into an ABI payload.
func (v Append) Pack() []byte {
	payload, err := eggtypes.Pack("append",
		v.Value,
	)
	if err != nil {
		panic(fmt.Sprintf("failed to pack Append: %v", err))
	}
	return payload
}

// Pack message Clear into an ABI payload.
func (v Clear) Pack() []byte {
	payload, err := eggtypes.Pack("clear")
	if err != nil {
		panic(fmt.Sprintf("failed to pack Clear: %v", err))
	}
	return payload
}

// Pack message TextBox into an ABI payload.
func (v TextBox) Pack() []byte {
	payload, err := eggtypes.Pack("textBox",
		v.Value,
	)
	if err != nil {
		panic(fmt.Sprintf("failed to pack TextBox: %v", err))
	}
	return payload
}

//
// Unpack
//

func _unpack_Append(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v Append
	v.Value, ok = values[0].(string)
	if !ok {
		return nil, fmt.Errorf("failed to unpack Append.Value")
	}
	return v, nil
}

func _unpack_Clear(values []any) (any, error) {
	if len(values) != 0 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var v Clear
	return v, nil
}

func _unpack_TextBox(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v TextBox
	v.Value, ok = values[0].(string)
	if !ok {
		return nil, fmt.Errorf("failed to unpack TextBox.Value")
	}
	return v, nil
}

//
// Init
//

func init() {
	abiInterface, err := abi.JSON(strings.NewReader(_JSON_ABI))
	if err != nil {
		panic(fmt.Sprintf("failed to decode ABI: %v", err))
	}
	eggtypes.AddMethod(abiInterface.Methods["append"], _unpack_Append)
	eggtypes.AddMethod(abiInterface.Methods["clear"], _unpack_Clear)
	eggtypes.AddMethod(abiInterface.Methods["textBox"], _unpack_TextBox)
}
