// Code generated by EggRoll - DO NOT EDIT.

package main

import (
	"fmt"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/gligneul/eggroll/pkg/eggtypes"
)

var (
	_ = big.NewInt
	_ = common.Big1
	_ = eggtypes.PackValues
)

//
// Types
//

// Message with selector 86cdbae9
type Append struct {
	Value string
}

// Message with selector 52efea6e
type Clear struct {
}

// Message with selector 09df59d0
type TextBox struct {
	Value string
}

//
// IDs
//

// Append ID (86cdbae9)
var AppendID = [4]byte{134, 205, 186, 233}

// Clear ID (52efea6e)
var ClearID = [4]byte{82, 239, 234, 110}

// TextBox ID (09df59d0)
var TextBoxID = [4]byte{9, 223, 89, 208}

//
// Pack
//

// Pack message Append into an ABI payload.
func (v Append) Pack() []byte {
	payload, err := eggtypes.PackValues(AppendID,
		v.Value,
	)
	if err != nil {
		panic(fmt.Sprintf("failed to pack Append: %v", err))
	}
	return payload
}

// Pack message Clear into an ABI payload.
func (v Clear) Pack() []byte {
	payload, err := eggtypes.PackValues(ClearID)
	if err != nil {
		panic(fmt.Sprintf("failed to pack Clear: %v", err))
	}
	return payload
}

// Pack message TextBox into an ABI payload.
func (v TextBox) Pack() []byte {
	payload, err := eggtypes.PackValues(TextBoxID,
		v.Value,
	)
	if err != nil {
		panic(fmt.Sprintf("failed to pack TextBox: %v", err))
	}
	return payload
}

//
// Unpack
//

func _unpack_Append(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v Append
	v.Value, ok = values[0].(string)
	if !ok {
		return nil, fmt.Errorf("failed to unpack Append.Value")
	}
	return v, nil
}

func _unpack_Clear(values []any) (any, error) {
	if len(values) != 0 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var v Clear
	return v, nil
}

func _unpack_TextBox(values []any) (any, error) {
	if len(values) != 1 {
		return nil, fmt.Errorf("wrong number of values")
	}
	var ok bool
	var v TextBox
	v.Value, ok = values[0].(string)
	if !ok {
		return nil, fmt.Errorf("failed to unpack TextBox.Value")
	}
	return v, nil
}

//
// Init
//

func init() {
	const jsonAbi = `[
  {
    "name": "append",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "value",
        "type": "string",
        "internalType": "string",
        "components": null
      }
    ],
    "outputs": null
  },
  {
    "name": "clear",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": null,
    "outputs": null
  },
  {
    "name": "textBox",
    "type": "function",
    "stateMutability": "nonpayable",
    "inputs": [
      {
        "name": "value",
        "type": "string",
        "internalType": "string",
        "components": null
      }
    ],
    "outputs": null
  }
]
	`
	abiInterface, err := abi.JSON(strings.NewReader(jsonAbi))
	if err != nil {
		panic(fmt.Sprintf("failed to decode ABI: %v", err))
	}
	eggtypes.AddEncoding(eggtypes.Encoding{
		ID:        AppendID,
		Name:      "append",
		Arguments: abiInterface.Methods["append"].Inputs,
		Unpacker:  _unpack_Append,
	})
	eggtypes.AddEncoding(eggtypes.Encoding{
		ID:        ClearID,
		Name:      "clear",
		Arguments: abiInterface.Methods["clear"].Inputs,
		Unpacker:  _unpack_Clear,
	})
	eggtypes.AddEncoding(eggtypes.Encoding{
		ID:        TextBoxID,
		Name:      "textBox",
		Arguments: abiInterface.Methods["textBox"].Inputs,
		Unpacker:  _unpack_TextBox,
	})
}
